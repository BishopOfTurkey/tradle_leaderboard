<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tradle Leaderboard</title>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background-color: #ffffff;
            color: #374151;
            line-height: 1.6;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #111827;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            color: #6b7280;
            margin-bottom: 2rem;
        }

        .card {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .card h2 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #111827;
            margin-bottom: 1rem;
        }

        .accent-teal { color: #0d9488; }
        .accent-purple { color: #7c3aed; }
        .accent-green { color: #059669; }

        .btn {
            background-color: #0d9488;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background-color: #0f766e;
        }

        textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.875rem;
            resize: vertical;
            min-height: 120px;
        }

        textarea:focus {
            outline: none;
            border-color: #0d9488;
            box-shadow: 0 0 0 3px rgba(13, 148, 136, 0.1);
        }

        .message {
            padding: 0.75rem;
            border-radius: 6px;
            margin-top: 1rem;
        }

        .message.success {
            background-color: #d1fae5;
            color: #065f46;
        }

        .message.error {
            background-color: #fee2e2;
            color: #991b1b;
        }

        code {
            background-color: #f3f4f6;
            padding: 0.125rem 0.375rem;
            border-radius: 4px;
            font-size: 0.875rem;
        }

        input[type="text"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.875rem;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #0d9488;
            box-shadow: 0 0 0 3px rgba(13, 148, 136, 0.1);
        }

        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }

        .leaderboard-table th {
            background-color: #f9fafb;
            padding: 0.75rem 0.5rem;
            text-align: left;
            font-weight: 600;
            color: #374151;
            border-bottom: 2px solid #e5e7eb;
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }

        .leaderboard-table th:hover {
            background-color: #f3f4f6;
        }

        .leaderboard-table th.sorted-asc::after {
            content: ' â–²';
            font-size: 0.7rem;
        }

        .leaderboard-table th.sorted-desc::after {
            content: ' â–¼';
            font-size: 0.7rem;
        }

        .leaderboard-table td {
            padding: 0.75rem 0.5rem;
            border-bottom: 1px solid #e5e7eb;
        }

        .leaderboard-table tr:hover {
            background-color: #f9fafb;
        }

        .leaderboard-table .rank {
            font-weight: 600;
            color: #6b7280;
        }

        .leaderboard-table .player-name {
            font-weight: 500;
            color: #111827;
        }

        .leaderboard-table .stat {
            font-variant-numeric: tabular-nums;
        }

        .leaderboard-table .gold { color: #d97706; }
        .leaderboard-table .silver { color: #6b7280; }
        .leaderboard-table .bronze { color: #b45309; }

        .label {
            display: block;
            font-weight: 500;
            color: #374151;
            margin-bottom: 0.5rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="container" x-data="tradleApp()" x-init="init()">
        <h1>Tradle Leaderboard</h1>
        <p class="subtitle">Track your Tradle scores and compete with friends</p>

        <!-- Loading state -->
        <div x-show="loading" class="card">
            <p style="color: #6b7280;">Loading...</p>
        </div>

        <!-- No access state -->
        <div x-show="!loading && !blobId" class="card">
            <h2>Access Required</h2>
            <p style="color: #6b7280;">You need an invite link to access this leaderboard. The link should contain a blob parameter (e.g., <code>?blob=abc123</code>).</p>
        </div>

        <!-- Main content when authenticated -->
        <template x-if="!loading && blobId">
            <div>
                <div class="card">
                    <h2>Submit Your Score</h2>
                    <div class="form-group">
                        <label class="label" for="playerName">Your Name</label>
                        <input type="text" id="playerName" x-model="playerName" @change="savePlayerName()" placeholder="Enter your name">
                    </div>
                    <div class="form-group">
                        <label class="label" for="scoreInput">Tradle Result</label>
                        <textarea
                            id="scoreInput"
                            x-model="scoreInput"
                            placeholder="#Tradle #1419 5/6
ðŸŸ©â¬œâ¬œâ¬œâ¬œ
ðŸŸ©ðŸŸ©ðŸŸ¨â¬œâ¬œ
ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©â¬œ
ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ¨
ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
https://oec.world/en/games/tradle"></textarea>
                    </div>
                    <div>
                        <button class="btn" @click="submitScore()" :disabled="!playerName.trim()">Submit Score</button>
                    </div>
                    <div x-show="message" class="message" :class="messageType" x-text="message"></div>
                </div>

                <div class="card">
                    <h2>Leaderboard</h2>
                    <div x-show="scores.length === 0">
                        <p style="color: #6b7280;">No scores yet. Submit your first Tradle result!</p>
                    </div>
                    <div x-show="scores.length > 0">
                        <table class="leaderboard-table">
                            <thead>
                                <tr>
                                    <th @click="sortBy('rank')">#</th>
                                    <th @click="sortBy('player')" :class="getSortClass('player')">Player</th>
                                    <th @click="sortBy('avgScore')" :class="getSortClass('avgScore')">Avg Score</th>
                                    <th @click="sortBy('totalPoints')" :class="getSortClass('totalPoints')">Points</th>
                                    <th @click="sortBy('winRate')" :class="getSortClass('winRate')">Win %</th>
                                    <th @click="sortBy('gamesPlayed')" :class="getSortClass('gamesPlayed')">Games</th>
                                    <th @click="sortBy('streak')" :class="getSortClass('streak')">Streak</th>
                                </tr>
                            </thead>
                            <tbody>
                                <template x-for="(entry, index) in leaderboard" :key="entry.player">
                                    <tr>
                                        <td class="rank" :class="{'gold': index === 0, 'silver': index === 1, 'bronze': index === 2}" x-text="index + 1"></td>
                                        <td class="player-name" x-text="entry.player"></td>
                                        <td class="stat" x-text="entry.avgScore.toFixed(2)"></td>
                                        <td class="stat" x-text="entry.totalPoints"></td>
                                        <td class="stat" x-text="entry.winRate.toFixed(0) + '%'"></td>
                                        <td class="stat" x-text="entry.gamesPlayed"></td>
                                        <td class="stat" x-text="entry.streak"></td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </template>
    </div>

    <script>
        function tradleApp() {
            return {
                scoreInput: '',
                message: '',
                messageType: 'success',
                blobId: null,
                scores: [],
                loading: true,
                playerName: '',
                sortField: 'totalPoints',
                sortDirection: 'desc',

                async init() {
                    // Load player name from cookie
                    this.playerName = this.getCookie('tradlePlayerName') || '';
                    // Check URL parameter first
                    const urlParams = new URLSearchParams(window.location.search);
                    const blobParam = urlParams.get('blob');

                    if (blobParam) {
                        // Store in cookie and use it
                        this.setCookie('tradleBlobId', blobParam, 365);
                        this.blobId = blobParam;
                        // Clean URL
                        window.history.replaceState({}, document.title, window.location.pathname);
                    } else {
                        // Check cookie
                        this.blobId = this.getCookie('tradleBlobId');
                    }

                    if (this.blobId) {
                        await this.loadScores();
                    }
                    this.loading = false;
                },

                setCookie(name, value, days) {
                    const expires = new Date(Date.now() + days * 864e5).toUTCString();
                    document.cookie = `${name}=${encodeURIComponent(value)}; expires=${expires}; path=/; SameSite=Strict`;
                },

                getCookie(name) {
                    const value = `; ${document.cookie}`;
                    const parts = value.split(`; ${name}=`);
                    if (parts.length === 2) {
                        return decodeURIComponent(parts.pop().split(';').shift());
                    }
                    return null;
                },

                async loadScores() {
                    try {
                        const response = await fetch(`https://jsonblob.com/api/jsonBlob/${this.blobId}`);
                        if (response.ok) {
                            const data = await response.json();
                            this.scores = data.scores || [];
                        } else if (response.status === 404) {
                            this.message = 'Invalid blob ID. Please check your access link.';
                            this.messageType = 'error';
                            this.blobId = null;
                        }
                    } catch (error) {
                        console.error('Error loading scores:', error);
                        this.message = 'Failed to load scores. Please try again.';
                        this.messageType = 'error';
                    }
                },

                async saveScores() {
                    try {
                        const response = await fetch(`https://jsonblob.com/api/jsonBlob/${this.blobId}`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ scores: this.scores })
                        });
                        return response.ok;
                    } catch (error) {
                        console.error('Error saving scores:', error);
                        return false;
                    }
                },

                savePlayerName() {
                    if (this.playerName.trim()) {
                        this.setCookie('tradlePlayerName', this.playerName.trim(), 365);
                    }
                },

                parseScore(input) {
                    const lines = input.trim().split('\n');
                    const headerMatch = lines[0].match(/#Tradle #(\d+) (\d|X)\/6/);

                    if (!headerMatch) {
                        return null;
                    }

                    const gameNumber = parseInt(headerMatch[1]);
                    const scoreRaw = headerMatch[2];
                    const score = scoreRaw === 'X' ? 7 : parseInt(scoreRaw);
                    const solved = scoreRaw !== 'X';

                    return {
                        gameNumber,
                        score,
                        solved,
                        raw: input.trim(),
                        timestamp: new Date().toISOString(),
                        player: this.playerName.trim()
                    };
                },

                get leaderboard() {
                    // Group scores by player
                    const playerStats = {};

                    for (const score of this.scores) {
                        const player = score.player || 'Anonymous';
                        if (!playerStats[player]) {
                            playerStats[player] = {
                                player,
                                scores: [],
                                totalScore: 0,
                                solvedGames: 0,
                                totalPoints: 0
                            };
                        }

                        playerStats[player].scores.push(score);
                        playerStats[player].totalScore += score.score;
                        if (score.solved) {
                            playerStats[player].solvedGames++;
                        }
                        // Points: 1/6=6pts, 2/6=5pts, 3/6=4pts, 4/6=3pts, 5/6=2pts, 6/6=1pt, X/6=0pts
                        const points = score.solved ? (7 - score.score) : 0;
                        playerStats[player].totalPoints += points;
                    }

                    // Calculate derived stats for each player
                    const leaderboardData = Object.values(playerStats).map(stats => {
                        const gamesPlayed = stats.scores.length;
                        const avgScore = gamesPlayed > 0 ? stats.totalScore / gamesPlayed : 0;
                        const winRate = gamesPlayed > 0 ? (stats.solvedGames / gamesPlayed) * 100 : 0;

                        // Calculate current streak
                        const sortedScores = [...stats.scores].sort((a, b) => b.gameNumber - a.gameNumber);
                        let streak = 0;
                        for (const s of sortedScores) {
                            if (s.solved) {
                                streak++;
                            } else {
                                break;
                            }
                        }

                        return {
                            player: stats.player,
                            avgScore,
                            totalPoints: stats.totalPoints,
                            winRate,
                            gamesPlayed,
                            streak
                        };
                    });

                    // Sort leaderboard
                    leaderboardData.sort((a, b) => {
                        let valA = a[this.sortField];
                        let valB = b[this.sortField];

                        // For avgScore, lower is better so reverse the comparison
                        if (this.sortField === 'avgScore') {
                            [valA, valB] = [valB, valA];
                        }

                        if (typeof valA === 'string') {
                            valA = valA.toLowerCase();
                            valB = valB.toLowerCase();
                        }

                        if (this.sortDirection === 'asc') {
                            return valA > valB ? 1 : valA < valB ? -1 : 0;
                        } else {
                            return valA < valB ? 1 : valA > valB ? -1 : 0;
                        }
                    });

                    return leaderboardData;
                },

                sortBy(field) {
                    if (this.sortField === field) {
                        this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        this.sortField = field;
                        // Default sort directions
                        if (field === 'avgScore') {
                            this.sortDirection = 'asc'; // Lower is better
                        } else if (field === 'player') {
                            this.sortDirection = 'asc'; // Alphabetical
                        } else {
                            this.sortDirection = 'desc'; // Higher is better for other stats
                        }
                    }
                },

                getSortClass(field) {
                    if (this.sortField !== field) return '';
                    return this.sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc';
                },

                async submitScore() {
                    if (!this.blobId) {
                        this.message = 'No access. Please use an invite link with a valid blob ID.';
                        this.messageType = 'error';
                        return;
                    }

                    if (!this.playerName.trim()) {
                        this.message = 'Please enter your name before submitting a score.';
                        this.messageType = 'error';
                        return;
                    }

                    const parsed = this.parseScore(this.scoreInput);

                    if (!parsed) {
                        this.message = 'Invalid Tradle score format. Please paste your complete Tradle result.';
                        this.messageType = 'error';
                        return;
                    }

                    // Check for duplicate game number by the same player
                    const existingIndex = this.scores.findIndex(
                        s => s.gameNumber === parsed.gameNumber && s.player === parsed.player
                    );
                    if (existingIndex !== -1) {
                        this.message = `You already submitted a score for Game #${parsed.gameNumber}.`;
                        this.messageType = 'error';
                        return;
                    }

                    // Add score and save
                    this.scores.push(parsed);
                    const saved = await this.saveScores();

                    if (saved) {
                        this.message = `Score recorded: Game #${parsed.gameNumber} - ${parsed.solved ? parsed.score + '/6' : 'X/6'}`;
                        this.messageType = 'success';
                        this.scoreInput = '';
                    } else {
                        // Remove the score we just added since save failed
                        this.scores.pop();
                        this.message = 'Failed to save score. Please try again.';
                        this.messageType = 'error';
                    }
                }
            }
        }
    </script>
</body>
</html>
